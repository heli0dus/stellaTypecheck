-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Stella.Par
  ( happyError
  , myLexer
  , pProgram
  , pListStellaIdent
  , pLanguageDecl
  , pExtension
  , pListExtensionName
  , pListExtension
  , pDecl
  , pListDecl
  , pLocalDecl
  , pListLocalDecl
  , pAnnotation
  , pListAnnotation
  , pParamDecl
  , pListParamDecl
  , pReturnType
  , pThrowType
  , pType9
  , pListType9
  , pMatchCase
  , pListMatchCase
  , pOptionalTyping
  , pPatternData
  , pExprData
  , pPattern
  , pListPattern
  , pLabelledPattern
  , pListLabelledPattern
  , pBinding
  , pListBinding
  , pExpr
  , pListExpr
  , pExpr1
  , pPatternBinding
  , pListPatternBinding
  , pExpr2
  , pListExpr2
  , pExpr3
  , pExpr4
  , pExpr5
  , pExpr6
  , pExpr7
  , pType
  , pType1
  , pType2
  , pType3
  , pListType
  , pVariantFieldType
  , pListVariantFieldType
  , pRecordFieldType
  , pListRecordFieldType
  , pTyping
  ) where

import Prelude

import qualified Stella.Abs
import Stella.Lex

}

%name pProgram Program
%name pListStellaIdent ListStellaIdent
%name pLanguageDecl LanguageDecl
%name pExtension Extension
%name pListExtensionName ListExtensionName
%name pListExtension ListExtension
%name pDecl Decl
%name pListDecl ListDecl
%name pLocalDecl LocalDecl
%name pListLocalDecl ListLocalDecl
%name pAnnotation Annotation
%name pListAnnotation ListAnnotation
%name pParamDecl ParamDecl
%name pListParamDecl ListParamDecl
%name pReturnType ReturnType
%name pThrowType ThrowType
%name pType9 Type9
%name pListType9 ListType9
%name pMatchCase MatchCase
%name pListMatchCase ListMatchCase
%name pOptionalTyping OptionalTyping
%name pPatternData PatternData
%name pExprData ExprData
%name pPattern Pattern
%name pListPattern ListPattern
%name pLabelledPattern LabelledPattern
%name pListLabelledPattern ListLabelledPattern
%name pBinding Binding
%name pListBinding ListBinding
%name pExpr Expr
%name pListExpr ListExpr
%name pExpr1 Expr1
%name pPatternBinding PatternBinding
%name pListPatternBinding ListPatternBinding
%name pExpr2 Expr2
%name pListExpr2 ListExpr2
%name pExpr3 Expr3
%name pExpr4 Expr4
%name pExpr5 Expr5
%name pExpr6 Expr6
%name pExpr7 Expr7
%name pType Type
%name pType1 Type1
%name pType2 Type2
%name pType3 Type3
%name pListType ListType
%name pVariantFieldType VariantFieldType
%name pListVariantFieldType ListVariantFieldType
%name pRecordFieldType RecordFieldType
%name pListRecordFieldType ListRecordFieldType
%name pTyping Typing
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='            { PT _ (TS _ 1)             }
  '&'             { PT _ (TS _ 2)             }
  '('             { PT _ (TS _ 3)             }
  ')'             { PT _ (TS _ 4)             }
  '*'             { PT _ (TS _ 5)             }
  '+'             { PT _ (TS _ 6)             }
  ','             { PT _ (TS _ 7)             }
  '-'             { PT _ (TS _ 8)             }
  '->'            { PT _ (TS _ 9)             }
  '.'             { PT _ (TS _ 10)            }
  '/'             { PT _ (TS _ 11)            }
  ':'             { PT _ (TS _ 12)            }
  ':='            { PT _ (TS _ 13)            }
  ';'             { PT _ (TS _ 14)            }
  '<'             { PT _ (TS _ 15)            }
  '<='            { PT _ (TS _ 16)            }
  '<|'            { PT _ (TS _ 17)            }
  '='             { PT _ (TS _ 18)            }
  '=='            { PT _ (TS _ 19)            }
  '=>'            { PT _ (TS _ 20)            }
  '>'             { PT _ (TS _ 21)            }
  '>='            { PT _ (TS _ 22)            }
  'Bool'          { PT _ (TS _ 23)            }
  'Bot'           { PT _ (TS _ 24)            }
  'List::head'    { PT _ (TS _ 25)            }
  'List::isempty' { PT _ (TS _ 26)            }
  'List::tail'    { PT _ (TS _ 27)            }
  'Nat'           { PT _ (TS _ 28)            }
  'Nat::iszero'   { PT _ (TS _ 29)            }
  'Nat::pred'     { PT _ (TS _ 30)            }
  'Nat::rec'      { PT _ (TS _ 31)            }
  'Top'           { PT _ (TS _ 32)            }
  'Unit'          { PT _ (TS _ 33)            }
  '['             { PT _ (TS _ 34)            }
  ']'             { PT _ (TS _ 35)            }
  'and'           { PT _ (TS _ 36)            }
  'as'            { PT _ (TS _ 37)            }
  'auto'          { PT _ (TS _ 38)            }
  'cast'          { PT _ (TS _ 39)            }
  'catch'         { PT _ (TS _ 40)            }
  'cons'          { PT _ (TS _ 41)            }
  'core'          { PT _ (TS _ 42)            }
  'else'          { PT _ (TS _ 43)            }
  'exception'     { PT _ (TS _ 44)            }
  'extend'        { PT _ (TS _ 45)            }
  'false'         { PT _ (TS _ 46)            }
  'fix'           { PT _ (TS _ 47)            }
  'fn'            { PT _ (TS _ 48)            }
  'fold'          { PT _ (TS _ 49)            }
  'forall'        { PT _ (TS _ 50)            }
  'generic'       { PT _ (TS _ 51)            }
  'if'            { PT _ (TS _ 52)            }
  'in'            { PT _ (TS _ 53)            }
  'inl'           { PT _ (TS _ 54)            }
  'inline'        { PT _ (TS _ 55)            }
  'inr'           { PT _ (TS _ 56)            }
  'language'      { PT _ (TS _ 57)            }
  'let'           { PT _ (TS _ 58)            }
  'letrec'        { PT _ (TS _ 59)            }
  'match'         { PT _ (TS _ 60)            }
  'new'           { PT _ (TS _ 61)            }
  'not'           { PT _ (TS _ 62)            }
  'or'            { PT _ (TS _ 63)            }
  'panic!'        { PT _ (TS _ 64)            }
  'return'        { PT _ (TS _ 65)            }
  'succ'          { PT _ (TS _ 66)            }
  'then'          { PT _ (TS _ 67)            }
  'throw'         { PT _ (TS _ 68)            }
  'throws'        { PT _ (TS _ 69)            }
  'true'          { PT _ (TS _ 70)            }
  'try'           { PT _ (TS _ 71)            }
  'type'          { PT _ (TS _ 72)            }
  'unfold'        { PT _ (TS _ 73)            }
  'unit'          { PT _ (TS _ 74)            }
  'variant'       { PT _ (TS _ 75)            }
  'with'          { PT _ (TS _ 76)            }
  '{'             { PT _ (TS _ 77)            }
  '|'             { PT _ (TS _ 78)            }
  '|>'            { PT _ (TS _ 79)            }
  '}'             { PT _ (TS _ 80)            }
  'µ'             { PT _ (TS _ 81)            }
  L_integ         { PT _ (TI $$)              }
  L_StellaIdent   { PT _ (T_StellaIdent $$)   }
  L_ExtensionName { PT _ (T_ExtensionName $$) }
  L_MemoryAddress { PT _ (T_MemoryAddress $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

StellaIdent :: { Stella.Abs.StellaIdent }
StellaIdent  : L_StellaIdent { Stella.Abs.StellaIdent $1 }

ExtensionName :: { Stella.Abs.ExtensionName }
ExtensionName  : L_ExtensionName { Stella.Abs.ExtensionName $1 }

MemoryAddress :: { Stella.Abs.MemoryAddress }
MemoryAddress  : L_MemoryAddress { Stella.Abs.MemoryAddress $1 }

Program :: { Stella.Abs.Program }
Program
  : LanguageDecl ListExtension ListDecl { Stella.Abs.AProgram $1 $2 $3 }

ListStellaIdent :: { [Stella.Abs.StellaIdent] }
ListStellaIdent
  : {- empty -} { [] }
  | StellaIdent { (:[]) $1 }
  | StellaIdent ',' ListStellaIdent { (:) $1 $3 }

LanguageDecl :: { Stella.Abs.LanguageDecl }
LanguageDecl : 'language' 'core' ';' { Stella.Abs.LanguageCore }

Extension :: { Stella.Abs.Extension }
Extension
  : 'extend' 'with' ListExtensionName { Stella.Abs.AnExtension $3 }

ListExtensionName :: { [Stella.Abs.ExtensionName] }
ListExtensionName
  : {- empty -} { [] }
  | ExtensionName { (:[]) $1 }
  | ExtensionName ',' ListExtensionName { (:) $1 $3 }

ListExtension :: { [Stella.Abs.Extension] }
ListExtension
  : {- empty -} { [] } | Extension ';' ListExtension { (:) $1 $3 }

Decl :: { Stella.Abs.Decl }
Decl
  : ListAnnotation 'fn' StellaIdent '(' ListParamDecl ')' ReturnType ThrowType '{' ListDecl 'return' Expr '}' { Stella.Abs.DeclFun $1 $3 $5 $7 $8 $10 $12 }
  | ListAnnotation 'generic' 'fn' StellaIdent '[' ListStellaIdent ']' '(' ListParamDecl ')' ReturnType ThrowType '{' ListDecl 'return' Expr '}' { Stella.Abs.DeclFunGeneric $1 $4 $6 $9 $11 $12 $14 $16 }
  | 'type' StellaIdent '=' Type { Stella.Abs.DeclTypeAlias $2 $4 }
  | 'exception' 'type' '=' Type { Stella.Abs.DeclExceptionType $4 }
  | 'exception' 'variant' StellaIdent ':' Type { Stella.Abs.DeclExceptionVariant $3 $5 }

ListDecl :: { [Stella.Abs.Decl] }
ListDecl : {- empty -} { [] } | Decl ListDecl { (:) $1 $2 }

LocalDecl :: { Stella.Abs.LocalDecl }
LocalDecl : Decl { Stella.Abs.ALocalDecl $1 }

ListLocalDecl :: { [Stella.Abs.LocalDecl] }
ListLocalDecl
  : {- empty -} { [] } | LocalDecl ';' ListLocalDecl { (:) $1 $3 }

Annotation :: { Stella.Abs.Annotation }
Annotation : 'inline' { Stella.Abs.InlineAnnotation }

ListAnnotation :: { [Stella.Abs.Annotation] }
ListAnnotation
  : {- empty -} { [] } | Annotation ListAnnotation { (:) $1 $2 }

ParamDecl :: { Stella.Abs.ParamDecl }
ParamDecl : StellaIdent ':' Type { Stella.Abs.AParamDecl $1 $3 }

ListParamDecl :: { [Stella.Abs.ParamDecl] }
ListParamDecl
  : {- empty -} { [] }
  | ParamDecl { (:[]) $1 }
  | ParamDecl ',' ListParamDecl { (:) $1 $3 }

ReturnType :: { Stella.Abs.ReturnType }
ReturnType
  : {- empty -} { Stella.Abs.NoReturnType }
  | '->' Type { Stella.Abs.SomeReturnType $2 }

ThrowType :: { Stella.Abs.ThrowType }
ThrowType
  : {- empty -} { Stella.Abs.NoThrowType }
  | 'throws' ListType9 { Stella.Abs.SomeThrowType $2 }

Type9 :: { Stella.Abs.Type }
Type9 : Type { $1 }

ListType9 :: { [Stella.Abs.Type] }
ListType9 : Type9 { (:[]) $1 } | Type9 ',' ListType9 { (:) $1 $3 }

MatchCase :: { Stella.Abs.MatchCase }
MatchCase : Pattern '=>' Expr { Stella.Abs.AMatchCase $1 $3 }

ListMatchCase :: { [Stella.Abs.MatchCase] }
ListMatchCase
  : {- empty -} { [] }
  | MatchCase { (:[]) $1 }
  | MatchCase '|' ListMatchCase { (:) $1 $3 }

OptionalTyping :: { Stella.Abs.OptionalTyping }
OptionalTyping
  : {- empty -} { Stella.Abs.NoTyping }
  | ':' Type { Stella.Abs.SomeTyping $2 }

PatternData :: { Stella.Abs.PatternData }
PatternData
  : {- empty -} { Stella.Abs.NoPatternData }
  | '=' Pattern { Stella.Abs.SomePatternData $2 }

ExprData :: { Stella.Abs.ExprData }
ExprData
  : {- empty -} { Stella.Abs.NoExprData }
  | '=' Expr { Stella.Abs.SomeExprData $2 }

Pattern :: { Stella.Abs.Pattern }
Pattern
  : Pattern 'cast' 'as' Type { Stella.Abs.PatternCastAs $1 $4 }
  | Pattern 'as' Type { Stella.Abs.PatternAsc $1 $3 }
  | '<|' StellaIdent PatternData '|>' { Stella.Abs.PatternVariant $2 $3 }
  | 'inl' '(' Pattern ')' { Stella.Abs.PatternInl $3 }
  | 'inr' '(' Pattern ')' { Stella.Abs.PatternInr $3 }
  | '{' ListPattern '}' { Stella.Abs.PatternTuple $2 }
  | '{' ListLabelledPattern '}' { Stella.Abs.PatternRecord $2 }
  | '[' ListPattern ']' { Stella.Abs.PatternList $2 }
  | 'cons' '(' Pattern ',' Pattern ')' { Stella.Abs.PatternCons $3 $5 }
  | '(' Pattern ',' Pattern ')' { Stella.Abs.patternCons $2 $4 }
  | 'false' { Stella.Abs.PatternFalse }
  | 'true' { Stella.Abs.PatternTrue }
  | 'unit' { Stella.Abs.PatternUnit }
  | Integer { Stella.Abs.PatternInt $1 }
  | 'succ' '(' Pattern ')' { Stella.Abs.PatternSucc $3 }
  | StellaIdent { Stella.Abs.PatternVar $1 }
  | '(' Pattern ')' { $2 }

ListPattern :: { [Stella.Abs.Pattern] }
ListPattern
  : {- empty -} { [] }
  | Pattern { (:[]) $1 }
  | Pattern ',' ListPattern { (:) $1 $3 }

LabelledPattern :: { Stella.Abs.LabelledPattern }
LabelledPattern
  : StellaIdent '=' Pattern { Stella.Abs.ALabelledPattern $1 $3 }

ListLabelledPattern :: { [Stella.Abs.LabelledPattern] }
ListLabelledPattern
  : LabelledPattern { (:[]) $1 }
  | LabelledPattern ',' ListLabelledPattern { (:) $1 $3 }

Binding :: { Stella.Abs.Binding }
Binding : StellaIdent '=' Expr { Stella.Abs.ABinding $1 $3 }

ListBinding :: { [Stella.Abs.Binding] }
ListBinding
  : Binding { (:[]) $1 } | Binding ',' ListBinding { (:) $1 $3 }

Expr :: { Stella.Abs.Expr }
Expr
  : Expr1 ';' Expr { Stella.Abs.Sequence $1 $3 }
  | Expr1 ';' { $1 }
  | 'let' ListPatternBinding 'in' Expr { Stella.Abs.Let $2 $4 }
  | 'letrec' ListPatternBinding 'in' Expr { Stella.Abs.LetRec $2 $4 }
  | 'generic' '[' ListStellaIdent ']' Expr { Stella.Abs.TypeAbstraction $3 $5 }
  | Expr1 { $1 }

ListExpr :: { [Stella.Abs.Expr] }
ListExpr
  : {- empty -} { [] }
  | Expr { (:[]) $1 }
  | Expr ',' ListExpr { (:) $1 $3 }

Expr1 :: { Stella.Abs.Expr }
Expr1
  : Expr2 ':=' Expr1 { Stella.Abs.Assign $1 $3 }
  | 'if' Expr1 'then' Expr1 'else' Expr1 { Stella.Abs.If $2 $4 $6 }
  | Expr2 { $1 }

PatternBinding :: { Stella.Abs.PatternBinding }
PatternBinding
  : Pattern '=' Expr { Stella.Abs.APatternBinding $1 $3 }

ListPatternBinding :: { [Stella.Abs.PatternBinding] }
ListPatternBinding
  : PatternBinding { (:[]) $1 }
  | PatternBinding ',' ListPatternBinding { (:) $1 $3 }

Expr2 :: { Stella.Abs.Expr }
Expr2
  : Expr3 '<' Expr3 { Stella.Abs.LessThan $1 $3 }
  | Expr3 '<=' Expr3 { Stella.Abs.LessThanOrEqual $1 $3 }
  | Expr3 '>' Expr3 { Stella.Abs.GreaterThan $1 $3 }
  | Expr3 '>=' Expr3 { Stella.Abs.GreaterThanOrEqual $1 $3 }
  | Expr3 '==' Expr3 { Stella.Abs.Equal $1 $3 }
  | Expr3 '!=' Expr3 { Stella.Abs.NotEqual $1 $3 }
  | Expr3 { $1 }

ListExpr2 :: { [Stella.Abs.Expr] }
ListExpr2
  : Expr2 ';' { (:[]) $1 } | Expr2 ';' ListExpr2 { (:) $1 $3 }

Expr3 :: { Stella.Abs.Expr }
Expr3
  : Expr3 'as' Type2 { Stella.Abs.TypeAsc $1 $3 }
  | Expr3 'cast' 'as' Type2 { Stella.Abs.TypeCast $1 $4 }
  | 'fn' '(' ListParamDecl ')' '{' 'return' Expr '}' { Stella.Abs.Abstraction $3 $7 }
  | '<|' StellaIdent ExprData '|>' { Stella.Abs.Variant $2 $3 }
  | 'match' Expr2 '{' ListMatchCase '}' { Stella.Abs.Match $2 $4 }
  | '[' ListExpr ']' { Stella.Abs.List $2 }
  | Expr3 '+' Expr4 { Stella.Abs.Add $1 $3 }
  | Expr3 '-' Expr4 { Stella.Abs.Subtract $1 $3 }
  | Expr3 'or' Expr4 { Stella.Abs.LogicOr $1 $3 }
  | Expr4 { $1 }

Expr4 :: { Stella.Abs.Expr }
Expr4
  : Expr4 '*' Expr5 { Stella.Abs.Multiply $1 $3 }
  | Expr4 '/' Expr5 { Stella.Abs.Divide $1 $3 }
  | Expr4 'and' Expr5 { Stella.Abs.LogicAnd $1 $3 }
  | Expr5 { $1 }

Expr5 :: { Stella.Abs.Expr }
Expr5
  : 'new' '(' Expr ')' { Stella.Abs.Ref $3 }
  | '*' Expr5 { Stella.Abs.Deref $2 }
  | Expr6 { $1 }

Expr6 :: { Stella.Abs.Expr }
Expr6
  : Expr6 '(' ListExpr ')' { Stella.Abs.Application $1 $3 }
  | Expr6 '[' ListType ']' { Stella.Abs.TypeApplication $1 $3 }
  | Expr6 '.' StellaIdent { Stella.Abs.DotRecord $1 $3 }
  | Expr6 '.' Integer { Stella.Abs.DotTuple $1 $3 }
  | '{' ListExpr '}' { Stella.Abs.Tuple $2 }
  | '{' ListBinding '}' { Stella.Abs.Record $2 }
  | 'cons' '(' Expr ',' Expr ')' { Stella.Abs.ConsList $3 $5 }
  | 'List::head' '(' Expr ')' { Stella.Abs.Head $3 }
  | 'List::isempty' '(' Expr ')' { Stella.Abs.IsEmpty $3 }
  | 'List::tail' '(' Expr ')' { Stella.Abs.Tail $3 }
  | 'panic!' { Stella.Abs.Panic }
  | 'throw' '(' Expr ')' { Stella.Abs.Throw $3 }
  | 'try' '{' Expr '}' 'catch' '{' Pattern '=>' Expr '}' { Stella.Abs.TryCatch $3 $7 $9 }
  | 'try' '{' Expr '}' 'with' '{' Expr '}' { Stella.Abs.TryWith $3 $7 }
  | 'try' '{' Expr '}' 'cast' 'as' Type '{' Pattern '=>' Expr '}' 'with' '{' Expr '}' { Stella.Abs.TryCastAs $3 $7 $9 $11 $15 }
  | 'inl' '(' Expr ')' { Stella.Abs.Inl $3 }
  | 'inr' '(' Expr ')' { Stella.Abs.Inr $3 }
  | 'succ' '(' Expr ')' { Stella.Abs.Succ $3 }
  | 'not' '(' Expr ')' { Stella.Abs.LogicNot $3 }
  | 'Nat::pred' '(' Expr ')' { Stella.Abs.Pred $3 }
  | 'Nat::iszero' '(' Expr ')' { Stella.Abs.IsZero $3 }
  | 'fix' '(' Expr ')' { Stella.Abs.Fix $3 }
  | 'Nat::rec' '(' Expr ',' Expr ',' Expr ')' { Stella.Abs.NatRec $3 $5 $7 }
  | 'fold' '[' Type ']' Expr7 { Stella.Abs.Fold $3 $5 }
  | 'unfold' '[' Type ']' Expr7 { Stella.Abs.Unfold $3 $5 }
  | Expr7 { $1 }

Expr7 :: { Stella.Abs.Expr }
Expr7
  : 'true' { Stella.Abs.ConstTrue }
  | 'false' { Stella.Abs.ConstFalse }
  | 'unit' { Stella.Abs.ConstUnit }
  | Integer { Stella.Abs.ConstInt $1 }
  | MemoryAddress { Stella.Abs.ConstMemory $1 }
  | StellaIdent { Stella.Abs.Var $1 }
  | '(' Expr ')' { $2 }

Type :: { Stella.Abs.Type }
Type
  : 'auto' { Stella.Abs.TypeAuto }
  | 'fn' '(' ListType ')' '->' Type { Stella.Abs.TypeFun $3 $6 }
  | 'forall' ListStellaIdent '.' Type { Stella.Abs.TypeForAll $2 $4 }
  | 'µ' StellaIdent '.' Type { Stella.Abs.TypeRec $2 $4 }
  | Type1 { $1 }

Type1 :: { Stella.Abs.Type }
Type1 : Type2 '+' Type2 { Stella.Abs.TypeSum $1 $3 } | Type2 { $1 }

Type2 :: { Stella.Abs.Type }
Type2
  : '{' ListType '}' { Stella.Abs.TypeTuple $2 }
  | '{' ListRecordFieldType '}' { Stella.Abs.TypeRecord $2 }
  | '<|' ListVariantFieldType '|>' { Stella.Abs.TypeVariant $2 }
  | '[' Type ']' { Stella.Abs.TypeList $2 }
  | Type3 { $1 }

Type3 :: { Stella.Abs.Type }
Type3
  : 'Bool' { Stella.Abs.TypeBool }
  | 'Nat' { Stella.Abs.TypeNat }
  | 'Unit' { Stella.Abs.TypeUnit }
  | 'Top' { Stella.Abs.TypeTop }
  | 'Bot' { Stella.Abs.TypeBottom }
  | '&' Type2 { Stella.Abs.TypeRef $2 }
  | StellaIdent { Stella.Abs.TypeVar $1 }
  | '(' Type ')' { $2 }

ListType :: { [Stella.Abs.Type] }
ListType
  : {- empty -} { [] }
  | Type { (:[]) $1 }
  | Type ',' ListType { (:) $1 $3 }

VariantFieldType :: { Stella.Abs.VariantFieldType }
VariantFieldType
  : StellaIdent OptionalTyping { Stella.Abs.AVariantFieldType $1 $2 }

ListVariantFieldType :: { [Stella.Abs.VariantFieldType] }
ListVariantFieldType
  : {- empty -} { [] }
  | VariantFieldType { (:[]) $1 }
  | VariantFieldType ',' ListVariantFieldType { (:) $1 $3 }

RecordFieldType :: { Stella.Abs.RecordFieldType }
RecordFieldType
  : StellaIdent ':' Type { Stella.Abs.ARecordFieldType $1 $3 }

ListRecordFieldType :: { [Stella.Abs.RecordFieldType] }
ListRecordFieldType
  : RecordFieldType { (:[]) $1 }
  | RecordFieldType ',' ListRecordFieldType { (:) $1 $3 }

Typing :: { Stella.Abs.Typing }
Typing : Expr ':' Type { Stella.Abs.ATyping $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

